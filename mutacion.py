# -*- coding: utf-8 -*-
"""
Created on Sun Jun 30 16:52:33 2019

@author: monic
"""

import random

def init_population(population, target, letters): 
    """Generates the initial population.
    
    Args:
        
        population: an integer number defined to be the total population.
        target: a string defined to be the desired result of the mutation
        letters: a string which has all the alphabetic characters including space.
    
    Returns:
        
        A list of n=population elements, each one is a random string with the lenght of the target.
    
    """
    words=[] #Open the list were the population will be along the process
    for j in range(population):
        word=""
        for i in range(len(target)):
            word+=random.choice(letters) #Create random words of the target's lenght
        words.append([0,word]) #Add them to the list, with a counter in index[0] 
    return words #Return the created list 
        
def fitness(words, target): 
    """Scores the population.
    
    Gives to a each random string, a punctuation depending on how many of the random letters
    matched with the target string.
    
    Args:
        
        words: a list of random strings with the same lenght
        target: a string defined to be the desired result of the mutation
    
    Returns:
        
        A list of lists in which each element has the [int, string] form
    
    """
    for entry in words: #for each element in words
        word=entry[1] #Take the second argument which is the word
        score=0 #start the scor in zero
        for i in range(len(word)):
            if word[i]==target[i]:
                score+=1 #If the letter in the index position matchs, add 1
            entry[0] = score #Assign the new score
    return words #Return the new scored list

def ordering(words): 
    """Orders the population.
    
    The best punctuated elements will be the first in the list now.

    Args:
        
        words: a list of random strings with the same lenght and a given score
    
    Returns:
        
        A scored list of lists in which each element has the [int, string] form,
        starting with the high scores until the baddest ones 
    
    """
    words=sorted(words, reverse=True)
    return words

def elimination(words, population, treshold_worst): 
    """Eliminates the last n terms.
    
    The last 20% of the elements into the list, will be elements in the [0,''] form 

    Args:
        
        words: a list of random strings with the same lenght and a given score
        population: an integer number defined to be the total population.
        treshold_worst: a float number which represents a percent of the worst
    
    Returns:
        
        A scored list of lists in which each element has the [int, string] form,
        starting with the high scores and where the treshold_worst% elements will be [0,'']
    
    """
    index = int(population*treshold_worst) #80% 
    for i in range(index,population): #for the worst 20% of the population
        words[i]=[0,''] #Eliminate the word, empty string, 0 counter
    return words #Return the list with the 20% of the last empty values

#Make n children from the n best parents    
def crossover(words, population, treshold_worst, treshold_parent):
    """Generates new words from the best population.
    
    The last 20% of the elements into the list, will be new elements in the [0,string] form 

    Args:
        
        words: a list of random strings with the same lenght and a given score
        population: an integer number defined to be the total population.
        treshold_worst: a float number which represents a percent of the worst
        treshold_parent: a float number which represents a percent of the best
    
    Returns:
        
        A scored list of lists in which each element has the [int, string] form,
        starting with the high scores and where the treshold_worst% elements will be 
        in the form [0,'new string'], generated by mixing the treshold_parent%
        best population. These last, are not scored yet. 
    
    """
    index= int(population*treshold_parent) #10%
    parents=words[:index] #Create a parents list made of the best 10% 
    index= int(population*treshold_worst) #80%
    for i in range(index, population): #For the worst 20% of the population (empty lists)
        parent1= random.choice(parents) #Select a parent1
        parent2= random.choice(parents) #Select a parent 2
        parent1, parent2= parent1[1], parent2[1]
        child=""
        for j in range(len(parent1)): #The child will have the same lenght of his parents
            choice=random.random()
            if choice >0.5:
                child+=parent1[j]
            else:
                child+=parent2[j]
        words[i][1]=child #Put him into the empty spaces 
    return words #Return a new list with the new children as the new last 20% 

#Mutate, or not, some of the children
def mutation(words, treshold_mutation, treshold_worst, population, letters):
    """Mutates some of the generated children in the crossover stage
    
    The last 20% of the elements into the list, will be elements in the [0,mutated_string] form 

    Args:
        
        words: a list of random strings with the same lenght and a given score
        population: an integer number defined to be the total population.
        treshold_worst: a float number which represents a percent of the worst
        treshold_mutation: a float number which represents the probability that a mutation occurs
        letters: a string which has all the alphabetic characters including space.
    
    Returns:
        
        A scored list of lists in which each element has the [int, string] form,
        starting with the high scores and where the treshold_worst% elements will be 
        in the form [0,'mutated_string']. These last, are not scored yet. 
    
    """
    index= int(population*treshold_worst) #80%
    for i in range(index, population): #For the last 20%, i.e., the children
        word=words[i][1]
        choice=random.random() #Probability
        if choice < treshold_mutation: #If it is less than 10%
            index=random.randint(0, len(word)-1) #Select which index will be mutated
            word=word[:index] + random.choice(letters) + word[index+1:] #Modify the word
            words[i][1]=word #Mutate them
    return words #Return a list with the mutated chidren

